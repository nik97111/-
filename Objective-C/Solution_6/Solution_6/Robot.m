//
//  Robot.m
//  Solution_6
//
//  Created by Николай Чупреев on 28.01.2024.
//

// Задание
// 1. Написать класс Робот со свойствами: x, y, name. Координаты и имя соответственно.

#import "Robot.h"

@implementation Robot
// Заметки
// Для того, чтобы класс Robot соответсвовал протоколу <NSCoding>, нужно следующее:
// 1. Чтобы сохранить объект, нужно закодировать (превратить в сырые (двоичные) данные): нужен алгоритм, который описывает, как это будет происходить. Все действия по кодировке объекта должны быть указаны в методе - (void)encodeWithCoder. Это обязательный метод, без которого класс не будет соответсвовать протоколу <NSCoding>
// 2. Обратное действие. Если есть сырые данные (ранее из объекта получены данные), то нужно создать объект класса. Для этого нужен инициализатор - (instancetype)initWithCoder), который обязателен при подписании на протокол <NSCoding>
// Чтобы структура класаа была правильной, очередность объявления следующая: вначале располагаются инициализаторы, потом методы

// 1.2
// Создаем кастомный инициализатор, который принимает два параметра: x, y со значениями x, y
- (instancetype)initWithX:(float)x y:(float)y name:(NSString *)name {
    // Определяем, кто такой self
    self = [super init];
    // Проверяем, что self создался (присутствует в памяти)
    if (self) {
        // Задаем свойство объекта - self.x
        self.x = x;
        // Задаем свойство объекта - self.y
        self.y = y;
        // Задаем свойство объекта - self.name
        self.name = name;
    }
    // Возвращаем self
    return self;
}

// 1.4
// Создаем объект класса по сырым данным (полученным в // 3)
- (instancetype)initWithCoder:(NSCoder *)decoder {
    // Определяем, кто такой self
    self = [super init];
    // Проверяем, что self создался (присутствует в памяти)
    if (self) {
        // Задаем свойство объекта - self.x, обратившись - к coder и раскодировать - метод decodeObjectForKey по ключу - @"X" (название ключа, по которому ранее кодировали цвет)
        self.x = [decoder decodeFloatForKey:@"X"];
        // Задаем свойство объекта - self.y, обратившись - к coder и раскодировать - метод decodeObjectForKey по ключу - @"Y" (название ключа, по которому ранее кодировали цвет)
        self.y = [decoder decodeFloatForKey:@"Y"];
        // Задаем свойство объекта - self.name, обратившись - к coder и раскодировать - метод decodeObjectForKey по ключу - @"Name" (название ключа, по которому ранее кодировали цвет)
        self.name = [decoder decodeObjectForKey:@"Name"];
    }
    // Возвращаем self
    return self;
}

// 1.3
// Определяем метод, который кодирует объект (превращает его в сырые данные)
// Чтобы записать в userDefaults класс, нужно закодировать: растащить все свойства, которые данный класс поддерживает и сохранить их отдельно. Поэтому в - (void)encodeWithCoder нужно каждое свойство закодировать в отдельном userDefaults. userDefaults не вызывается, работает через класс coder.
//- (void)encodeWithCoder:(NSCoder *)encoder
- (void)encodeWithCoder:(NSCoder *)encoder {
    // Обращаемся к coder, у него есть метод encodeFloat, кодирующий объект. Далее указываеv объект - x (который будет закодирован): обращаемся к self.x. Далее указываем второй параметр - метод forKey (чтобы обратиться к объекту по ключу (указываем ключ, по которому происходит сохранение - @"X"))
    [encoder encodeFloat:self.x forKey:@"X"];
    // Обращаемся к coder, у него есть метод encodeFloat, кодирующий объект. Далее указываеv объект - y (который будет закодирован): обращаемся к self.y. Далее указываем второй параметр - метод forKey (чтобы обратиться к объекту по ключу (указываем ключ, по которому происходит сохранение - @"Y"))
    [encoder encodeFloat:self.y forKey:@"Y"];
    // Обращаемся к coder, у него есть метод encodeObject, кодирующий объект. Далее указываеv объект -  name (который будет закодирован): обращаемся к self.name. Далее указываем второй параметр - метод forKey (чтобы обратиться к объекту по ключу (указываем ключ, по которому происходит сохранение - @"Name"))
    [encoder encodeObject:self.name forKey:@"Name"];
}

@end

